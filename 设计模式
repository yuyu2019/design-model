
1、用UML绘制出三种工厂模式的类结构图。


2、深刻理解产品族和产品等级结构之间的关系。
产品族：不同产品同一厂家生产
产品等级结构：同一个产品不同产品厂家生产

3、自主完成三种工厂模式的代码实现，理解简单工厂、工厂方法和抽象工厂的区别。
简单工厂：
package com.gperedu.vip.factory;

//�򵥹�������
interface Car {
	public void driver();
}

class AudiCar implements Car {
	public void driver() {
		System.out.println("driver audi");
	}
}

class BaoCar implements Car {
	public void driver() {
		System.out.println("driver baoshijie");
	}
}

class CarFactory {
	public static Car createCar(String car) {
		Car c = null;
		if ("audi".equals(car)) {
			c = new AudiCar();
		} else if ("baoshijie".equals(car)) {
			c = new BaoCar();
		}
		return c;
	}
}

public class SimpleFactoryTest {
	public static void main(String[] args) {
		Car car = CarFactory.createCar("audi");
		car.driver();
	}

}

工厂方法：
package com.gperedu.vip.factory;

interface FactoryMethod{
	Car1 createCar();
}
interface Car1 {
	public void driver();
}

class AudiCar1 implements Car1 {
	public void driver() {
		System.out.println("driver audi");
	}
}

class BaoCar1 implements Car1 {
	public void driver() {
		System.out.println("driver baoshijie");
	}
}
class AudiCarFactory implements FactoryMethod{
	public  Car1 createCar(){
		return new AudiCar1();
	}	
}
class BaoCarFactory implements FactoryMethod {
	public Car1 createCar() {
		return new BaoCar1();
	}	
}

public class FactoryMethodTest {
	public static void main(String[] args){
	FactoryMethod factory = new BaoCarFactory();
    Car1 car1 = factory.createCar();
    car1.driver();
	}
}

抽象工厂：
package com.gperedu.vip.factory;

interface AbstractFactory {
	Fridge createFridge();

	AirCondition createAirCondition();

}

interface Fridge {
	void ice();
}

interface AirCondition {
	void cool();
}

class FridgeA implements Fridge {
	public void ice() {
		System.out.println("ice");
	}
}

class AirConditionA implements AirCondition {
	public void cool() {
		System.out.println("cool");
	}
}

class FactoryA implements AbstractFactory{
	public Fridge createFridge(){
		return new FridgeA();
	}

	public AirCondition createAirCondition(){
		return new AirConditionA();
	}
}
public class AbstractFactoryTest {
	public static void main(String[] args) {
		FactoryA factoryA = new FactoryA();
		factoryA.createFridge().ice();
		
	}
}

单例模式作业内容
1、熟练掌握单例模式的常见写法。
饿汉、懒汉、注册、ThreadLocal
2、总结每种单例写法的优、缺点。
饿汉式单例:优点：没有加任何的锁，执行效率比较高，用户体验比较好
           缺点：浪费内存空间
懒汉式单例:优点：线程安全
           缺点：浪费内存空间
注册式单例:优点：枚举单例：线程安全、防反射、序列化破坏单例模式
                 容器式单例：用于创建实例非常多的情况，便于管理
           缺点：枚举单例：浪费内存空间
                 容器式单例：非线程安全
ThreadLocal单例：优点：能保证在单个线程中是唯一的，天生的线程安全
                  缺点： 不能保证其创建的对象是全局唯一
3、思考破坏单例模式的方式有哪些？并且归纳总结。
序列化和反射
   反射：普通java类可以通过反射获取到构造方法，从而调用构造方法创建新对象。

         但是枚举类方式单例不能通过发射破坏，因为枚举单例反编译后可以看到，枚举类实际内部没有无参构造方法。另外，如果反射想通过调用有参构造方法，去创建实例时，反射机制的调用源码已经做了判断，判断当前调用类是否是枚举，如果是枚举类，则不允许进行反射调用构造方法创建实例对象。

   序列化：序列化方式，当读取文件流生成对象时，如果是object类型，会去检查是否含有构造方法，如果有，会重新newInstance创建新对象。如果是枚举类型，会没有调用new 对象的动作，而是根据枚举名称直接获取枚举值。所以枚举类方式单例不会被反序列化破解
4、梳理内部类的执行逻辑，并画出时序图。

























代理模式
装饰者模式				适配器模式		
装饰者和被装饰者拥有相同的超类型(可能是抽象类也可能是接口				是为了接口的转换		
						
						
注重覆盖、扩展				注重兼容、转换		
前置考虑				后置考虑		
有层级关系				无层级关系		
is-a关系				has-a关系		
